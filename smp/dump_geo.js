/*
 * dump geometry data generated by hbin2json in Houdini hclassic format
 * this sample handles vector attributes for points
 */

const fs = require("fs");

function json_to_hgeo(json) {
	console.log("PGEOMETRY V5");
	let numPoints = json.npnt;
	let numPolygons = json.npol;
	let numTriangles = json.ntri;
	let numPntAttrs = json.npntVecAttrs;
	console.log("NPoints " + numPoints + " NPrims " + numPolygons);
	console.log("NPointGroups " + 0 + " NPrimGroups " + 0);
	console.log("NPointAttrib " + numPntAttrs + " NVertexAttrib " + 0 + " NPrimAttrib " + 0 + " NAttrib " + 0);

	if (numPntAttrs > 0) {
		console.log("PointAttrib");
		for (let iattr = 0; iattr < numPntAttrs; ++iattr) {
			let attrName = json.pntVecAttrNames[iattr];
			let attrType = "float";
			if (attrName == "N") {
				attrType = "vector";
			}
			console.log(attrName + " 3 " + attrType + " 0 0 0");
		}
	}

	for (let ipnt = 0; ipnt < numPoints; ++ipnt) {
		let attrStr = ""
		if (numPntAttrs > 0) {
			attrStr += " (";
			for (let iattr = 0; iattr < numPntAttrs; ++iattr) {
				let attrIdx = (iattr*numPoints + ipnt) * 3;
				if (iattr > 0) attrStr += "  ";
				attrStr += json.pntsVecData[attrIdx] + " " + json.pntsVecData[attrIdx + 1] + " " + json.pntsVecData[attrIdx + 2];
			}
			attrStr += ")";
		}
		let idx = ipnt * 3;
		console.log(json.pnts[idx] + " " + json.pnts[idx + 1] + " " + json.pnts[idx + 2] + " 1" + attrStr);
	}

	if (numPolygons > 0) {
		console.log("Run " + numPolygons + " Poly");
		if (numPolygons == numTriangles) {
			/*
				triangulated geo
				to save space all triangles are stores in json.triIdx[] 
				json.pols[] and json.polIdx[] are empty
				[tri0[v0], tri0[v1], tri0[v2], tri1[v0], tri1[v1], tri1[v2], ...]
			*/
			for (let i = 0; i < numTriangles; ++i) {
				let triOrg = i * 3;
				let pntListStr = ""
				for (let j = 0; j < 3; ++j) {
					pntListStr += " " + json.triIdx[triOrg + j];
				}
				console.log(" 3 <" + pntListStr);
			}
		} else {
			/*
				geo consists of arbitrary polygons
				polygons are stored as pairs of numbers in json.pols[]:
				[start0, nverts0, start1,  nverts1, ...]
				start* is where the list of polygon's vertex indices begins in json.polIdx[]
			*/
			for (let i = 0; i < numPolygons; ++i) {
				let idx = i * 2;
				let polStart = json.pols[idx]; // start index in json.polIdx[]
				let vertsPerPol = json.pols[idx + 1];
				let pntListStr = ""
				for (let i = 0; i < vertsPerPol; ++i) {
					pntListStr += " " + json.polIdx[polStart + i];
				}
				console.log(" " + vertsPerPol + " <" + pntListStr);
			}
		}
	}

	console.log("beginExtra");
	console.log("endExtra");
}

function main(args) {
	if (args.length < 1) {
		console.log("json_info <path>");
		return;
	}
	let inPath = args[0];
	let inData = fs.readFileSync(inPath);
	let jsonData = JSON.parse(inData);
	if (jsonData.dataType === undefined) {
		console.log("data type is unknown");
		return;
	}
	if (jsonData.dataType == "geo") {
		json_to_hgeo(jsonData);
	} else {
		console.log("data type is not geo");
		return;
	}
}

main(process.argv.slice(2));
